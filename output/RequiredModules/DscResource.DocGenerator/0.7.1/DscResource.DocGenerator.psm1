#Region './prefix.ps1' 0
# This is added to the top of the generated file module file.

$script:resourceHelperModulePath = Join-Path -Path $PSScriptRoot -ChildPath '.\Modules\DscResource.Common'

Import-Module -Name $script:resourceHelperModulePath

$script:localizedData = Get-LocalizedData -DefaultUICulture 'en-US'

<#
    Define enumeration for use by help example generation to determine the type of
    block that a text line is within.
#>
if (-not ([System.Management.Automation.PSTypeName]'HelpExampleBlockType').Type)
{
    $typeDefinition = @'
    public enum HelpExampleBlockType
    {
        None,
        PSScriptInfo,
        Configuration,
        ExampleCommentHeader
    }
'@
    Add-Type -TypeDefinition $typeDefinition
}

<#
    Define enumeration for use by wiki example generation to determine the type of
    block that a text line is within.
#>
if (-not ([System.Management.Automation.PSTypeName]'WikiExampleBlockType').Type)
{
    $typeDefinition = @'
    public enum WikiExampleBlockType
    {
        None,
        PSScriptInfo,
        Configuration,
        ExampleCommentHeader
    }
'@
    Add-Type -TypeDefinition $typeDefinition
}
#EndRegion './prefix.ps1' 43
#Region './Private/Copy-WikiFolder.ps1' 0
<#
    .SYNOPSIS
        Copies any Wiki files from the module into the Wiki and optionally overwrite
        any existing files.

    .PARAMETER Path
        The path to the output that was generated by New-DscResourceWikiPage.

    .PARAMETER DestinationPath
        The destination path for the Wiki files.

    .PARAMETER WikiSourcePath
        The name of the folder that contains the source Wiki files.

    .EXAMPLE
        Copy-WikiFolder -Path '.\output\WikiContent' -DestinationPath 'c:\repoName.wiki.git' -WikiSourcePath '.\source\WikiSource'

        Copies any Wiki files from the module into the Wiki.
#>
function Copy-WikiFolder
{
    [CmdletBinding()]
    param
    (
        [Parameter(Mandatory = $true)]
        [System.String]
        $Path,

        [Parameter(Mandatory = $true)]
        [System.String]
        $DestinationPath,

        [Parameter()]
        [System.Management.Automation.SwitchParameter]
        $Force
    )

    Write-Verbose -Message ($localizedData.CopyWikiFoldersMessage -f ($Path -join ''', '''))

    $wikiFiles = Get-ChildItem -Path $Path

    foreach ($file in $wikiFiles)
    {
        Write-Verbose -Message ($localizedData.CopyFileMessage -f $file.Name)

        Copy-Item -Path $file.FullName -Destination $DestinationPath -Force:$Force
    }
}
#EndRegion './Private/Copy-WikiFolder.ps1' 48
#Region './Private/Get-BuiltModuleVersion.ps1' 0
<#
    .SYNOPSIS
        This function returns the version from a built module's module manifest.

    .PARAMETER OutputDirectory
        The path to the output folder where the module is built, e.g.
        'c:\MyModule\output'.

    .PARAMETER ProjectName
        The name of the project, normally the name of the module that is being
        built.

    .EXAMPLE
        Get-BuiltModuleVersion -OutputDirectory 'c:\MyModule\output' -ProjectName 'MyModule'

        Will evaluate the module version from the module manifest in the path
        c:\MyModule\output\MyModule\*\MyModule.psd1.

    .NOTES
        This is the same function that exits in the module Sampler, so if the
        function there is moved or exposed it should be reused from there instead.
#>
function Get-BuiltModuleVersion
{
    [CmdletBinding()]
    [OutputType([System.String])]
    param
    (
        [Parameter()]
        [System.String]
        $OutputDirectory,

        [Parameter()]
        [System.String]
        $ProjectName
    )

    $ModuleManifestPath = "$OutputDirectory/$ProjectName/*/$ProjectName.psd1"

    Write-Verbose -Message (
        "Get the module version from module manifest in path '{0}'." -f $ModuleManifestPath
    )

    $moduleInfo = Import-PowerShellDataFile $ModuleManifestPath -ErrorAction 'Stop'

    $ModuleVersion = $moduleInfo.ModuleVersion

    if ($moduleInfo.PrivateData.PSData.Prerelease)
    {
        $ModuleVersion = $ModuleVersion + '-' + $moduleInfo.PrivateData.PSData.Prerelease
    }

    $moduleVersionParts = Split-ModuleVersion -ModuleVersion $ModuleVersion

    Write-Verbose -Message (
        "Current module version is '{0}'." -f $moduleVersionParts.ModuleVersion
    )

    return $moduleVersionParts.ModuleVersion
}
#EndRegion './Private/Get-BuiltModuleVersion.ps1' 60
#Region './Private/Get-DscResourceHelpExampleContent.ps1' 0
<#
    .SYNOPSIS
        This function reads an example file from a resource and converts
        it to help text for inclusion in a PowerShell help file.

    .DESCRIPTION
        The function will read the example PS1 file and convert the
        help header into the description text for the example.

    .PARAMETER ExamplePath
        The path to the example file.

    .PARAMETER ModulePath
        The number of the example.

    .EXAMPLE
        Get-DscResourceHelpExampleContent -ExamplePath 'C:\repos\NetworkingDsc\Examples\Resources\DhcpClient\1-DhcpClient_EnableDHCP.ps1' -ExampleNumber 1

        Reads the content of 'C:\repos\NetworkingDsc\Examples\Resources\DhcpClient\1-DhcpClient_EnableDHCP.ps1'
        and converts it to help text in preparation for being added to a PowerShell help file.
#>
function Get-DscResourceHelpExampleContent
{
    [CmdletBinding()]
    [OutputType([System.String])]
    param
    (
        [Parameter(Mandatory = $true)]
        [System.String]
        $ExamplePath,

        [Parameter(Mandatory = $true)]
        [System.Int32]
        $ExampleNumber
    )

    $exampleContent = Get-Content -Path $ExamplePath

    # Use a string builder to assemble the example description and code
    $exampleDescriptionStringBuilder = New-Object -TypeName System.Text.StringBuilder
    $exampleCodeStringBuilder = New-Object -TypeName System.Text.StringBuilder

    <#
        Step through each line in the source example and determine
        the content and act accordingly:
        \<#PSScriptInfo...#\> - Drop block
        \#Requires - Drop Line
        \<#...#\> - Drop .EXAMPLE, .SYNOPSIS and .DESCRIPTION but include all other lines
        Configuration ... - Include entire block until EOF
    #>
    $blockType = [HelpExampleBlockType]::None

    foreach ($exampleLine in $exampleContent)
    {
        Write-Debug -Message ('Processing Line: {0}' -f $exampleLine)

        # Determine the behavior based on the current block type
        switch ($blockType.ToString())
        {
            'PSScriptInfo'
            {
                Write-Debug -Message 'PSScriptInfo Block Processing'

                # Exclude PSScriptInfo block from any output
                if ($exampleLine -eq '#>')
                {
                    Write-Debug -Message 'PSScriptInfo Block Ended'

                    # End of the PSScriptInfo block
                    $blockType = [HelpExampleBlockType]::None
                }
            }

            'Configuration'
            {
                Write-Debug -Message 'Configuration Block Processing'

                # Include all lines in the configuration block in the code output
                $null = $exampleCodeStringBuilder.AppendLine($exampleLine)
            }

            'ExampleCommentHeader'
            {
                Write-Debug -Message 'ExampleCommentHeader Block Processing'

                # Include all lines in Example Comment Header block except for headers
                $exampleLine = $exampleLine.TrimStart()

                if ($exampleLine -notin ('.SYNOPSIS', '.DESCRIPTION', '.EXAMPLE', '#>'))
                {
                    # Not a header so add this to the output
                    $null = $exampleDescriptionStringBuilder.AppendLine($exampleLine)
                }

                if ($exampleLine -eq '#>')
                {
                    Write-Debug -Message 'ExampleCommentHeader Block Ended'

                    # End of the Example Comment Header block
                    $blockType = [HelpExampleBlockType]::None
                }
            }

            default
            {
                Write-Debug -Message 'Not Currently Processing Block'

                # Check the current line
                if ($exampleLine.TrimStart() -eq  '<#PSScriptInfo')
                {
                    Write-Debug -Message 'PSScriptInfo Block Started'

                    $blockType = [HelpExampleBlockType]::PSScriptInfo
                }
                elseif ($exampleLine -match 'Configuration')
                {
                    Write-Debug -Message 'Configuration Block Started'

                    $null = $exampleCodeStringBuilder.AppendLine($exampleLine)
                    $blockType = [HelpExampleBlockType]::Configuration
                }
                elseif ($exampleLine.TrimStart() -eq '<#')
                {
                    Write-Debug -Message 'ExampleCommentHeader Block Started'

                    $blockType = [HelpExampleBlockType]::ExampleCommentHeader
                }
            }
        }
    }

    # Assemble the final output
    $null = $exampleStringBuilder = New-Object -TypeName System.Text.StringBuilder
    $null = $exampleStringBuilder.AppendLine(".EXAMPLE $ExampleNumber")
    $null = $exampleStringBuilder.AppendLine()
    $null = $exampleStringBuilder.AppendLine($exampleDescriptionStringBuilder)
    $null = $exampleStringBuilder.Append($exampleCodeStringBuilder)

    # ALways return CRLF as line endings to work cross platform.
    return ($exampleStringBuilder.ToString() -replace '\r?\n', "`r`n")
}
#EndRegion './Private/Get-DscResourceHelpExampleContent.ps1' 141
#Region './Private/Get-DscResourceSchemaPropertyContent.ps1' 0
<#
    .SYNOPSIS
        Get-DscResourceSchemaPropertyContent is used to generate the parameter content
        for the wiki page.

    .DESCRIPTION
        Get-DscResourceSchemaPropertyContent is used to generate the parameter content
        for the wiki page.

    .PARAMETER Attribute
        A hash table with properties that is returned by Get-MofSchemaObject in
        the property Attributes.

    .EXAMPLE
        $content = Get-DscResourceSchemaPropertyContent -Property @(
                @{
                    Name             = 'StringProperty'
                    DataType         = 'String'
                    IsArray          = $false
                    State            = 'Key'
                    Description      = 'Any description'
                    EmbeddedInstance = $null
                    ValueMap         = $null
                }
            )

        Returns the parameter content based on the passed array of parameter metadata.
#>
function Get-DscResourceSchemaPropertyContent
{
    [CmdletBinding()]
    [OutputType([System.String[]])]
    param
    (
        [Parameter(Mandatory = $true)]
        [System.Collections.Hashtable[]]
        $Property
    )

    $stringArray = [System.String[]] @()

    $stringArray += '| Parameter | Attribute | DataType | Description | Allowed Values |'
    $stringArray += '| --- | --- | --- | --- | --- |'

    foreach ($currentProperty in $Property)
    {
        if ($currentProperty.EmbeddedInstance -eq 'MSFT_Credential')
        {
            $dataType = 'PSCredential'
        }
        elseif (-not [System.String]::IsNullOrEmpty($currentProperty.EmbeddedInstance))
        {
            $dataType = $currentProperty.EmbeddedInstance
        }
        else
        {
            $dataType = $currentProperty.DataType
        }

        # If the attribute is an array, add [] to the DataType string.
        if ($currentProperty.IsArray)
        {
            $dataType = $dataType.ToString() + '[]'
        }

        $propertyLine = "| **$($currentProperty.Name)** " + `
                "| $($currentProperty.State) " + `
                "| $dataType " + `
                "| $($currentProperty.Description) |"

        if (-not [System.String]::IsNullOrEmpty($currentProperty.ValueMap))
        {
            $propertyLine += ' ' + ($currentProperty.ValueMap -join ', ')
        }

        $propertyLine += ' |'

        $stringArray += $propertyLine
    }

    return (, $stringArray)
}
#EndRegion './Private/Get-DscResourceSchemaPropertyContent.ps1' 82
#Region './Private/Get-DscResourceWikiExampleContent.ps1' 0
<#
    .SYNOPSIS
        This function reads an example file from a resource and converts
        it to markdown for inclusion in a resource wiki file.

    .DESCRIPTION
        The function will read the example PS1 file and convert the
        help header into the description text for the example. It will
        also surround the example configuration with code marks to
        indication it is powershell code.

    .PARAMETER ExamplePath
        The path to the example file.

    .PARAMETER ModulePath
        The number of the example.

    .EXAMPLE
        Get-DscResourceWikiExampleContent -ExamplePath 'C:\repos\NetworkingDsc\Examples\Resources\DhcpClient\1-DhcpClient_EnableDHCP.ps1' -ExampleNumber 1

        Reads the content of 'C:\repos\NetworkingDsc\Examples\Resources\DhcpClient\1-DhcpClient_EnableDHCP.ps1'
        and converts it to markdown in preparation for being added to a resource wiki page.
#>

function Get-DscResourceWikiExampleContent
{
    [CmdletBinding()]
    [OutputType([System.String])]
    param
    (
        [Parameter(Mandatory = $true)]
        [System.String]
        $ExamplePath,

        [Parameter(Mandatory = $true)]
        [System.Int32]
        $ExampleNumber
    )

    $exampleContent = Get-Content -Path $ExamplePath

    # Use a string builder to assemble the example description and code
    $exampleDescriptionStringBuilder = New-Object -TypeName System.Text.StringBuilder
    $exampleCodeStringBuilder = New-Object -TypeName System.Text.StringBuilder

    <#
        Step through each line in the source example and determine
        the content and act accordingly:
        \<#PSScriptInfo...#\> - Drop block
        \#Requires - Drop Line
        \<#...#\> - Drop .EXAMPLE, .SYNOPSIS and .DESCRIPTION but include all other lines
        Configuration ... - Include entire block until EOF
    #>
    $blockType = [WikiExampleBlockType]::None

    foreach ($exampleLine in $exampleContent)
    {
        Write-Debug -Message ('Processing Line: {0}' -f $exampleLine)

        # Determine the behavior based on the current block type
        switch ($blockType.ToString())
        {
            'PSScriptInfo'
            {
                Write-Debug -Message 'PSScriptInfo Block Processing'

                # Exclude PSScriptInfo block from any output
                if ($exampleLine -eq '#>')
                {
                    Write-Debug -Message 'PSScriptInfo Block Ended'

                    # End of the PSScriptInfo block
                    $blockType = [WikiExampleBlockType]::None
                }
            }

            'Configuration'
            {
                Write-Debug -Message 'Configuration Block Processing'

                # Include all lines in the configuration block in the code output
                $null = $exampleCodeStringBuilder.AppendLine($exampleLine)
            }

            'ExampleCommentHeader'
            {
                Write-Debug -Message 'ExampleCommentHeader Block Processing'

                # Include all lines in Example Comment Header block except for headers
                $exampleLine = $exampleLine.TrimStart()

                if ($exampleLine -notin ('.SYNOPSIS', '.DESCRIPTION', '.EXAMPLE', '#>'))
                {
                    # Not a header so add this to the output
                    $null = $exampleDescriptionStringBuilder.AppendLine($exampleLine)
                }

                if ($exampleLine -eq '#>')
                {
                    Write-Debug -Message 'ExampleCommentHeader Block Ended'

                    # End of the Example Comment Header block
                    $blockType = [WikiExampleBlockType]::None
                }
            }

            default
            {
                Write-Debug -Message 'Not Currently Processing Block'

                # Check the current line
                if ($exampleLine.TrimStart() -eq '<#PSScriptInfo')
                {
                    Write-Debug -Message 'PSScriptInfo Block Started'

                    $blockType = [WikiExampleBlockType]::PSScriptInfo
                }
                elseif ($exampleLine -match 'Configuration')
                {
                    Write-Debug -Message 'Configuration Block Started'

                    $null = $exampleCodeStringBuilder.AppendLine($exampleLine)
                    $blockType = [WikiExampleBlockType]::Configuration
                }
                elseif ($exampleLine.TrimStart() -eq '<#')
                {
                    Write-Debug -Message 'ExampleCommentHeader Block Started'

                    $blockType = [WikiExampleBlockType]::ExampleCommentHeader
                }
            }
        }
    }

    # Assemble the final output
    $null = $exampleStringBuilder = New-Object -TypeName System.Text.StringBuilder
    $null = $exampleStringBuilder.AppendLine("### Example $ExampleNumber")
    $null = $exampleStringBuilder.AppendLine()
    $null = $exampleStringBuilder.AppendLine($exampleDescriptionStringBuilder)
    $null = $exampleStringBuilder.AppendLine('```powershell')
    $null = $exampleStringBuilder.Append($exampleCodeStringBuilder)
    $null = $exampleStringBuilder.Append('```')

    # ALways return CRLF as line endings to work cross platform.
    return ($exampleStringBuilder.ToString() -replace '\r?\n', "`r`n")
}
#EndRegion './Private/Get-DscResourceWikiExampleContent.ps1' 146
#Region './Private/Get-MofSchemaObject.ps1' 0
<#
    .SYNOPSIS
        Get-MofSchemaObject is used to read a .schema.mof file for a DSC resource.

    .DESCRIPTION
        The Get-MofSchemaObject method is used to read the text content of the
        .schema.mof file that all MOF based DSC resources have. The object that
        is returned contains all of the data in the schema so it can be processed
        in other scripts.

    .PARAMETER FileName
        The full path to the .schema.mof file to process.

    .EXAMPLE
        $mof = Get-MofSchemaObject -FileName C:\repos\SharePointDsc\DSCRescoures\MSFT_SPSite\MSFT_SPSite.schema.mof

        This example parses a MOF schema file.
#>
function Get-MofSchemaObject
{
    [CmdletBinding()]
    [OutputType([System.Collections.Hashtable])]
    param
    (
        [Parameter(Mandatory = $true)]
        [System.String]
        $FileName
    )

    $temporaryPath = $null

    # Determine the correct $env:TEMP drive
    switch ($true)
    {
        (-not (Test-Path -Path variable:IsWindows) -or $IsWindows)
        {
            # Windows PowerShell or PowerShell 6+
            $temporaryPath = $env:TEMP
        }

        $IsMacOS
        {
            $temporaryPath = $env:TMPDIR

            throw 'NotImplemented: Currently there is an issue using the type [Microsoft.PowerShell.DesiredStateConfiguration.Internal.DscClassCache] on macOS. See issue https://github.com/PowerShell/PowerShell/issues/5970 and issue https://github.com/PowerShell/MMI/issues/33.'
        }

        $IsLinux
        {
            $temporaryPath = '/tmp'
        }

        Default
        {
            throw 'Cannot set the temporary path. Unknown operating system.'
        }
    }

    #region Workaround for OMI_BaseResource inheritance not resolving.

    $filePath = (Resolve-Path -Path $FileName).Path
    $tempFilePath = Join-Path -Path $temporaryPath -ChildPath "DscMofHelper_$((New-Guid).Guid).tmp"
    $rawContent = (Get-Content -Path $filePath -Raw) -replace '\s*:\s*OMI_BaseResource'

    Set-Content -LiteralPath $tempFilePath -Value $rawContent -ErrorAction 'Stop'

    # .NET methods don't like PowerShell drives
    $tempFilePath = Convert-Path -Path $tempFilePath

    #endregion

    try
    {
        $exceptionCollection = [System.Collections.ObjectModel.Collection[System.Exception]]::new()
        $moduleInfo = [System.Tuple]::Create('Module', [System.Version] '1.0.0')

        $class = [Microsoft.PowerShell.DesiredStateConfiguration.Internal.DscClassCache]::ImportClasses(
            $tempFilePath, $moduleInfo, $exceptionCollection
        )
    }
    catch
    {
        throw "Failed to import classes from file $FileName. Error $_"
    }
    finally
    {
        Remove-Item -LiteralPath $tempFilePath -Force
    }

    foreach ($currentCimClass in $class)
    {
        $attributes = foreach ($property in $currentCimClass.CimClassProperties)
        {
            $state = switch ($property.flags)
            {
                { $_ -band [Microsoft.Management.Infrastructure.CimFlags]::Key }
                {
                    'Key'
                }
                { $_ -band [Microsoft.Management.Infrastructure.CimFlags]::Required }
                {
                    'Required'
                }
                { $_ -band [Microsoft.Management.Infrastructure.CimFlags]::ReadOnly }
                {
                    'Read'
                }
                default
                {
                    'Write'
                }
            }

            @{
                Name             = $property.Name
                State            = $state
                DataType         = $property.CimType
                ValueMap         = $property.Qualifiers.Where( { $_.Name -eq 'ValueMap' }).Value
                IsArray          = $property.CimType -gt 16
                Description      = $property.Qualifiers.Where( { $_.Name -eq 'Description' }).Value
                EmbeddedInstance = $property.Qualifiers.Where( { $_.Name -eq 'EmbeddedInstance' }).Value
            }
        }

        @{
            ClassName    = $currentCimClass.CimClassName
            Attributes   = $attributes
            ClassVersion = $currentCimClass.CimClassQualifiers.Where( { $_.Name -eq 'ClassVersion' }).Value
            FriendlyName = $currentCimClass.CimClassQualifiers.Where( { $_.Name -eq 'FriendlyName' }).Value
        }
    }
}
#EndRegion './Private/Get-MofSchemaObject.ps1' 132
#Region './Private/Invoke-Git.ps1' 0
<#
    .SYNOPSIS
        Invokes the git command.

    .PARAMETER Arguments
        The arguments to pass to the Git executable.

    .EXAMPLE
        Invoke-Git clone https://github.com/X-Guardian/xActiveDirectory.wiki.git --quiet

        Invokes the Git executable to clone the specified repository to the current working directory.
#>

function Invoke-Git
{
    [CmdletBinding()]
    param
    (
        [Parameter(ValueFromRemainingArguments = $true)]
        [System.String[]]
        $Arguments
    )

    $argumentsJoined = $Arguments -join ' '

    # Trying to remove any access token from the debug output.
    if ($argumentsJoined -match ':[\d|a-f].*@')
    {
        $argumentsJoined = $argumentsJoined -replace ':[\d|a-f].*@', ':RedactedToken@'
    }

    Write-Debug -Message ($localizedData.InvokingGitMessage -f $argumentsJoined)

    try
    {
        & git @Arguments

        <#
            Assuming error code 1 from git is warnings or informational like
            "nothing to commit, working tree clean" and those are returned
            instead of throwing an exception.
        #>
        if ($LASTEXITCODE -gt 1)
        {
            throw $LASTEXITCODE
        }
    }
    catch
    {
        throw $_
    }

    return $LASTEXITCODE
}
#EndRegion './Private/Invoke-Git.ps1' 54
#Region './Private/New-TempFolder.ps1' 0
<#
    .SYNOPSIS
        Creates a new temporary folder with a random name.

    .EXAMPLE
        New-TempFolder

        This command creates a new temporary folder with a random name.

    .PARAMETER MaximumRetries
        Specifies the maximum number of time to retry creating the temp folder.

    .OUTPUTS
        System.IO.DirectoryInfo
#>
function New-TempFolder
{
    [CmdletBinding()]
    [OutputType([System.IO.DirectoryInfo])]
    param (
        [Parameter()]
        [Int]
        $MaximumRetries = 10
    )

    $tempPath = [System.IO.Path]::GetTempPath()

    $retries = 0
    do
    {
        $retries++
        if ($Retries -gt $MaximumRetries)
        {
            throw ($localizedData.NewTempFolderCreationError -f $tempPath)
        }
        $name = [System.IO.Path]::GetRandomFileName()
        $path = New-Item -Path $tempPath -Name $name -ItemType Directory -ErrorAction SilentlyContinue
    }
    while (-not $path)

    return $path
}
#EndRegion './Private/New-TempFolder.ps1' 42
#Region './Private/New-WikiFooter.ps1' 0
<#
    .SYNOPSIS
        Creates the Wiki footer file if one does not already exist.

    .PARAMETER Path
        The path for the Wiki footer file.

    .PARAMETER BaseName
        The base name of the Wiki footer file. Defaults to '_Footer.md'.

    .EXAMPLE
        New-WikiFooter -Path $path

        Creates the Wiki footer.
#>
function New-WikiFooter
{
    [CmdletBinding()]
    param
    (
        [Parameter(Mandatory = $true)]
        [System.String]
        $Path,

        [Parameter()]
        [System.String]
        $BaseName = '_Footer.md'
    )

    $wikiFooterPath = Join-Path -Path $path -ChildPath $BaseName

    if (-not (Test-Path -Path $wikiFooterPath))
    {
        Write-Verbose -Message ($localizedData.GenerateWikiFooterMessage -f $BaseName)

        $wikiFooter = @()

        Out-File -InputObject $wikiFooter -FilePath $wikiFooterPath -Encoding ([System.Text.Encoding]::ASCII)
    }
}
#EndRegion './Private/New-WikiFooter.ps1' 40
#Region './Private/New-WikiSidebar.ps1' 0
<#
    .SYNOPSIS
        Creates the Wiki side bar file from the list of markdown files in the path.

    .PARAMETER ModuleName
        The name of the module to generate a new Wiki Sidebar file for.

    .PARAMETER Path
        The path to both create the Wiki Sidebar file and where to find the
        markdown files that was generated by New-DscResourceWikiPage, e.g.
        '.\output\WikiContent'.

    .PARAMETER BaseName
        The base name of the Wiki Sidebar file. Defaults to '_Sidebar.md'.

    .EXAMPLE
        New-WikiSidebar -ModuleName 'ActiveDirectoryDsc -Path '.\output\WikiContent'

        Creates the Wiki side bar from the list of markdown files in the path.
#>
function New-WikiSidebar
{
    [CmdletBinding()]
    param
    (
        [Parameter(Mandatory = $true)]
        [System.String]
        $ModuleName,

        [Parameter(Mandatory = $true)]
        [System.String]
        $Path,

        [Parameter()]
        [System.String]
        $BaseName = '_Sidebar.md'
    )

    $wikiSideBarPath = Join-Path -Path $Path -ChildPath $BaseName

    Write-Verbose -Message ($localizedData.GenerateWikiSidebarMessage -f $BaseName)

    $WikiSidebarContent = @(
        "# $ModuleName Module"
        ' '
    )

    $wikiFiles = Get-ChildItem -Path (Join-Path -Path $Path -ChildPath '*.md') -Exclude '_*.md'

    foreach ($file in $wikiFiles)
    {
        Write-Verbose -Message ("`t{0}" -f ($localizedData.AddFileToSideBar -f $file.Name))

        $WikiSidebarContent += "- [$($file.BaseName)]($($file.BaseName))"
    }

    Out-File -InputObject $WikiSidebarContent -FilePath $wikiSideBarPath -Encoding ([System.Text.Encoding]::ASCII)
}
#EndRegion './Private/New-WikiSidebar.ps1' 58
#Region './Private/Split-ModuleVersion.ps1' 0
<#
    .SYNOPSIS
        This function parses a module version string as returns a hashtable
        which each of the module version's parts.

    .PARAMETER ModuleVersion
        The module to parse.

    .EXAMPLE
        Split-ModuleVersion -ModuleVersion '1.15.0-pr0224-0022+Sha.47ae45eb'

        Splits the module version an returns a PSCustomObject with the parts
        of the module version.

        Version PreReleaseString ModuleVersion
        ------- ---------------- -------------
        1.15.0  pr0224           1.15.0-pr0224

    .NOTES
        This is only used by Get-BuiltModuleVersion, so if the function in Sampler
        is moved or exposed so we can remove Get-BuiltModuleVersion from this module
        then we should remove this function too.
#>
function Split-ModuleVersion
{
    [CmdletBinding()]
    [OutputType([System.Management.Automation.PSCustomObject])]
    param
    (
        [Parameter()]
        [System.String]
        $ModuleVersion
    )

    <#
        This handles a previous version of the module that suggested to pass
        a version string with metadata in the CI pipeline that can look like
        this: 1.15.0-pr0224-0022+Sha.47ae45eb2cfed02b249f239a7c55e5c71b26ab76.Date.2020-01-07
    #>
    $ModuleVersion = ($ModuleVersion -split '\+', 2)[0]

    $moduleVersion, $preReleaseString = $ModuleVersion -split '-', 2

    <#
        The cmldet Publish-Module does not yet support semver compliant
        pre-release strings. If the prerelease string contains a dash ('-')
        then the dash and everything behind is removed. For example
        'pr54-0012' is parsed to 'ps54'.
    #>
    $validPreReleaseString, $preReleaseStringSuffix = $preReleaseString -split '-'

    if ($validPreReleaseString)
    {
        $fullModuleVersion =  $moduleVersion + '-' + $validPreReleaseString
    }
    else
    {
        $fullModuleVersion =  $moduleVersion
    }

    $moduleVersionParts = [PSCustomObject] @{
        Version = $moduleVersion
        PreReleaseString = $validPreReleaseString
        ModuleVersion = $fullModuleVersion
    }

    return $moduleVersionParts
}
#EndRegion './Private/Split-ModuleVersion.ps1' 68
#Region './Private/Task.Generate_Conceptual_Help.ps1' 0
<#
    .SYNOPSIS
        This is the alias to the build task Generate_Conceptual_Help's script file.

    .DESCRIPTION
        This makes available the alias 'Task.Generate_Conceptual_Help' that is
        exported in the module manifest so that the build task can be correctly
        imported using for example Invoke-Build.

    .NOTES
        This is using the pattern lined out in the Invoke-Build repository
        https://github.com/nightroman/Invoke-Build/tree/master/Tasks/Import.
#>

Set-Alias -Name 'Task.Generate_Conceptual_Help' -Value "$PSScriptRoot/tasks/Generate_Conceptual_Help.build.ps1"
#EndRegion './Private/Task.Generate_Conceptual_Help.ps1' 15
#Region './Private/Task.Generate_Wiki_Content.ps1' 0
<#
    .SYNOPSIS
        This is the alias to the build task Generate_Wiki_Content's script file.

    .DESCRIPTION
        This makes available the alias 'Task.Generate_Wiki_Content' that is
        exported in the module manifest so that the build task can be correctly
        imported using for example Invoke-Build.

    .NOTES
        This is using the pattern lined out in the Invoke-Build repository
        https://github.com/nightroman/Invoke-Build/tree/master/Tasks/Import.
#>

Set-Alias -Name 'Task.Generate_Wiki_Content' -Value "$PSScriptRoot/tasks/Generate_Wiki_Content.build.ps1"
#EndRegion './Private/Task.Generate_Wiki_Content.ps1' 15
#Region './Private/Task.Publish_GitHub_Wiki_Content.ps1' 0
<#
    .SYNOPSIS
        This is the alias to the build task Publish_GitHub_Wiki_Content's script file.

    .DESCRIPTION
        This makes available the alias 'Task.Publish_GitHub_Wiki_Content' that is
        exported in the module manifest so that the build task can be correctly
        imported using for example Invoke-Build.

    .NOTES
        This is using the pattern lined out in the Invoke-Build repository
        https://github.com/nightroman/Invoke-Build/tree/master/Tasks/Import.
#>

Set-Alias -Name 'Task.Publish_GitHub_Wiki_Content' -Value "$PSScriptRoot/tasks/Publish_GitHub_Wiki_Content.build.ps1"
#EndRegion './Private/Task.Publish_GitHub_Wiki_Content.ps1' 15
#Region './Public/New-DscResourcePowerShellHelp.ps1' 0
<#
    .SYNOPSIS
        New-DscResourcePowerShellHelp generates PowerShell compatible help files
        for a DSC resource module

    .DESCRIPTION
        The New-DscResourcePowerShellHelp cmdlet will review all of the MOF based
        resources in a specified module directory and will inject PowerShell help
        files for each resource. These help files include details on the property
        types for each resource, as well as a text description and examples where
        they exist.

        The help files are output to the OutputPath directory if specified. If not,
        they are output to the relevant resource's 'en-US' directory either in the
        path set by 'ModulePath' or to 'DestinationModulePath' if set.

        A README.md with a text description must exist in the resource's subdirectory
        for the help file to be generated. To get examples added to the conceptual
        help the examples must be present in an individual resource example folder,
        e.g. 'Examples/Resources/<ResourceName>/1-Example.ps1'. Prefixing the value
        with a number will sort the examples in that order.

        These help files can then be read by passing the name of the resource as a
        parameter to Get-Help.

    .PARAMETER ModulePath
        The path to the root of the DSC resource module (where the PSD1 file is
        found). In this path the folder DSCResources must be present.

    .PARAMETER DestinationModulePath
        The destination module path can be used to set the path where module is
        built before being deployed. This must be set to the root of the built
        module, e.g 'c:\repos\ModuleName\output\ModuleName\1.0.0'.
        If OutputPath is also used at the same time that will override this path.

    .PARAMETER OutputPath
        The output path can be used to set the path where all the generated files
        will be saved (all files to the same path).

    .PARAMETER MarkdownCodeRegularExpression
        An array of regular expressions that should be used to parse the parameter
        descriptions in the schema MOF. Each regular expression must be written
        so that the capture group 0 is the full match and the capture group 1 is
        the text that should be kept.

    .EXAMPLE
        New-DscResourcePowerShellHelp -ModulePath C:\repos\SharePointDsc

        This example shows how to generate help for a specific module

    .EXAMPLE
        New-DscResourcePowerShellHelp -ModulePath C:\repos\SharePointDsc -DestinationModulePath C:\repos\SharePointDsc\output\SharePointDsc\1.0.0

        This example shows how to generate help for a specific module and output
        the result to a built module.

    .EXAMPLE
        New-DscResourcePowerShellHelp -ModulePath C:\repos\SharePointDsc -OutputPath C:\repos\SharePointDsc\en-US

        This example shows how to generate help for a specific module and output
        all the generated files to the same output path.

    .NOTES
        Line endings are hard-coded to CRLF to handle different platforms similar.
#>
function New-DscResourcePowerShellHelp
{
    [CmdletBinding()]
    param
    (
        [Parameter(Mandatory = $true)]
        [System.String]
        $ModulePath,

        [Parameter()]
        [System.String]
        $DestinationModulePath,

        [Parameter()]
        [System.String]
        $OutputPath,

        [Parameter()]
        [System.String[]]
        $MarkdownCodeRegularExpression = @()
    )

    $mofSearchPath = (Join-Path -Path $ModulePath -ChildPath '\**\*.schema.mof')
    $mofSchemas = @(Get-ChildItem -Path $mofSearchPath -Recurse)

    Write-Verbose -Message ($script:localizedData.FoundMofFilesMessage -f $mofSchemas.Count, $ModulePath)

    foreach ($mofSchema in $mofSchemas)
    {
        $result = (Get-MofSchemaObject -FileName $mofSchema.FullName) | Where-Object -FilterScript {
            ($_.ClassName -eq $mofSchema.Name.Replace('.schema.mof', '')) `
                -and ($null -ne $_.FriendlyName)
        }

        # This is a workaround for issue #42.
        $readMeFile = Get-ChildItem -Path $mofSchema.DirectoryName -ErrorAction 'SilentlyContinue' |
            Where-Object -FilterScript {
                $_.Name -like 'readme.md'
            }

        if ($readMeFile)
        {
            $descriptionPath = $readMeFile.FullName

            Write-Verbose -Message ($script:localizedData.GenerateHelpDocumentMessage -f $result.FriendlyName)

            $output = ".NAME`r`n"
            $output += "    $($result.FriendlyName)"
            $output += "`r`n`r`n"

            $descriptionContent = Get-Content -Path $descriptionPath -Raw
            $descriptionContent = $descriptionContent -replace '\r?\n', "`r`n"

            $descriptionContent = $descriptionContent -replace '\r\n', "`r`n    "
            $descriptionContent = $descriptionContent -replace '# Description\r\n    ', ".DESCRIPTION"
            $descriptionContent = $descriptionContent -replace '\r\n\s{4}\r\n', "`r`n`r`n"
            $descriptionContent = $descriptionContent -replace '\s{4}$', ''

            $output += $descriptionContent
            $output += "`r`n"

            foreach ($property in $result.Attributes)
            {
                $output += ".PARAMETER $($property.Name)`r`n"
                $output += "    $($property.State) - $($property.DataType)"
                $output += "`r`n"

                if ([string]::IsNullOrEmpty($property.ValueMap) -ne $true)
                {
                    $output += "    Allowed values: "

                    $property.ValueMap | ForEach-Object {
                        $output += $_ + ", "
                    }

                    $output = $output.TrimEnd(" ")
                    $output = $output.TrimEnd(",")
                    $output += "`r`n"
                }

                $propertyDescription = $property.Description

                if ($MarkdownCodeRegularExpression.Count -gt 0)
                {
                    foreach ($parseRegularExpression in $MarkdownCodeRegularExpression)
                    {
                        $allMatches = $propertyDescription | Select-String -Pattern $parseRegularExpression -AllMatches

                        foreach ($regularExpressionMatch in $allMatches.Matches)
                        {
                            <#
                                Always assume the group 0 is the full match and
                                the group 1 contain what we should replace with.
                            #>
                            $propertyDescription = $propertyDescription -replace @(
                                [RegEx]::Escape($regularExpressionMatch.Groups[0].Value),
                                $regularExpressionMatch.Groups[1].Value
                            )
                        }
                    }
                }

                $output += "    " + $propertyDescription
                $output += "`r`n`r`n"
            }

            $exampleSearchPath = "\Examples\Resources\$($result.FriendlyName)\*.ps1"
            $examplesPath = (Join-Path -Path $ModulePath -ChildPath $exampleSearchPath)
            $exampleFiles = @(Get-ChildItem -Path $examplesPath -ErrorAction SilentlyContinue)

            if ($exampleFiles.Count -gt 0)
            {
                $exampleCount = 1

                Write-Verbose -Message "Found $($exampleFiles.count) Examples for resource $($result.FriendlyName)"

                foreach ($exampleFile in $exampleFiles)
                {
                    $exampleContent = Get-DscResourceHelpExampleContent `
                        -ExamplePath $exampleFile.FullName `
                        -ExampleNumber ($exampleCount++)

                    $exampleContent = $exampleContent -replace '\r?\n', "`r`n"

                    $output += $exampleContent
                    $output += "`r`n"
                }
            }
            else
            {
                Write-Warning -Message ($script:localizedData.NoExampleFileFoundWarning -f $result.FriendlyName)
            }

            $outputFileName = "about_$($result.FriendlyName).help.txt"

            if ($PSBoundParameters.ContainsKey('OutputPath'))
            {
                # Output to $OutputPath if specified.
                $savePath = Join-Path -Path $OutputPath -ChildPath $outputFileName
            }
            elseif ($PSBoundParameters.ContainsKey('DestinationModulePath'))
            {
                # Output to the resource 'en-US' directory in the DestinationModulePath.
                $null = $mofSchema.DirectoryName -match '(.+)(DSCResources|DSCClassResources)(.+)'
                $resourceRelativePath = $matches[3]
                $dscRootFolderName = $matches[2]

                $savePath = Join-Path -Path $DestinationModulePath -ChildPath $dscRootFolderName |
                    Join-Path -ChildPath $resourceRelativePath |
                    Join-Path -ChildPath 'en-US' |
                    Join-Path -ChildPath $outputFileName
            }
            else
            {
                # Output to the resource 'en-US' directory in the ModulePath.
                $savePath = Join-Path -Path $mofSchema.DirectoryName -ChildPath 'en-US' |
                    Join-Path -ChildPath $outputFileName
            }

            Write-Verbose -Message ($script:localizedData.OutputHelpDocumentMessage -f $savePath)

            $output | Out-File -FilePath $savePath -Encoding 'ascii' -Force
        }
        else
        {
            Write-Warning -Message ($script:localizedData.NoDescriptionFileFoundWarning -f $result.FriendlyName)
        }
    }
}
#EndRegion './Public/New-DscResourcePowerShellHelp.ps1' 234
#Region './Public/New-DscResourceWikiPage.ps1' 0
<#
    .SYNOPSIS
        New-DscResourceWikiPage generates wiki pages that can be uploaded to GitHub
        to use as public documentation for a module.

    .DESCRIPTION
        The New-DscResourceWikiPage cmdlet will review all of the MOF based resources
        in a specified module directory and will output the Markdown files to the
        specified directory. These help files include details on the property types
        for each resource, as well as a text description and examples where they exist.

    .PARAMETER OutputPath
        Where should the files be saved to

    .PARAMETER ModulePath
        The path to the root of the DSC resource module (where the PSD1 file is found,
        not the folder for and individual DSC resource)

    .EXAMPLE
        New-DscResourceWikiPage `
            -ModulePath C:\repos\SharePointDsc\source `
            -OutputPath C:\repos\SharePointDsc\output\WikiContent

        This example shows how to generate help for a specific module
#>
function New-DscResourceWikiPage
{
    [CmdletBinding()]
    param
    (
        [Parameter(Mandatory = $true)]
        [System.String]
        $OutputPath,

        [Parameter(Mandatory = $true)]
        [System.String]
        $ModulePath
    )

    $mofSearchPath = Join-Path -Path $ModulePath -ChildPath '\**\*.schema.mof'
    $mofSchemaFiles = @(Get-ChildItem -Path $mofSearchPath -Recurse)

    Write-Verbose -Message ($script:localizedData.FoundMofFilesMessage -f $mofSchemaFiles.Count, $ModulePath)

    # Loop through all the Schema files found in the modules folder
    foreach ($mofSchemaFile in $mofSchemaFiles)
    {
        $mofSchemas = Get-MofSchemaObject -FileName $mofSchemaFile.FullName

        $dscResourceName = $mofSchemaFile.Name.Replace('.schema.mof', '')

        <#
            In a resource with one or more embedded instances (CIM classes) this
            will get the main resource CIM class.
        #>
        $resourceSchema = $mofSchemas |
            Where-Object -FilterScript {
                ($_.ClassName -eq $dscResourceName) -and ($null -ne $_.FriendlyName)
            }

        [System.Array] $readmeFile = Get-ChildItem -Path $mofSchemaFile.DirectoryName |
            Where-Object -FilterScript {
                $_.Name -like 'readme.md'
            }

        if ($readmeFile.Count -eq 1)
        {
            Write-Verbose -Message ($script:localizedData.GenerateWikiPageMessage -f $resourceSchema.FriendlyName)

            $output = New-Object -TypeName System.Text.StringBuilder

            $null = $output.AppendLine("# $($resourceSchema.FriendlyName)")
            $null = $output.AppendLine('')
            $null = $output.AppendLine('## Parameters')
            $null = $output.AppendLine('')

            $propertyContent = Get-DscResourceSchemaPropertyContent -Property $resourceSchema.Attributes

            foreach ($line in $propertyContent)
            {
                $null = $output.AppendLine($line)
            }

            <#
                In a resource with one or more embedded instances (CIM classes) this
                will get the embedded instances (CIM classes).
            #>
            $embeddedSchemas = $mofSchemas |
                Where-Object -FilterScript {
                    ($_.ClassName -ne $dscResourceName)
                }

            foreach ($embeddedSchema in $embeddedSchemas)
            {
                $null = $output.AppendLine()
                $null = $output.AppendLine("### $($embeddedSchema.ClassName)")
                $null = $output.AppendLine('')
                $null = $output.AppendLine('#### Parameters')
                $null = $output.AppendLine('')

                $propertyContent = Get-DscResourceSchemaPropertyContent -Property $embeddedSchema.Attributes

                foreach ($line in $propertyContent)
                {
                    $null = $output.AppendLine($line)
                }
            }

            $descriptionContent = Get-Content -Path $readmeFile.FullName -Raw

            # Change the description H1 header to an H2
            $descriptionContent = $descriptionContent -replace '# Description', '## Description'
            $null = $output.AppendLine()
            $null = $output.AppendLine($descriptionContent)

            $exampleSearchPath = "\Examples\Resources\$($resourceSchema.FriendlyName)\*.ps1"
            $examplesPath = (Join-Path -Path $ModulePath -ChildPath $exampleSearchPath)
            $exampleFiles = @(Get-ChildItem -Path $examplesPath -ErrorAction SilentlyContinue)

            if ($exampleFiles.Count -gt 0)
            {
                $null = $output.AppendLine('## Examples')
                $exampleCount = 1

                foreach ($exampleFile in $exampleFiles)
                {
                    Write-Verbose -Message "Adding Example file '$($exampleFile.Name)' to wiki page for $($resourceSchema.FriendlyName)"

                    $exampleContent = Get-DscResourceWikiExampleContent `
                        -ExamplePath $exampleFile.FullName `
                        -ExampleNumber ($exampleCount++)

                    $null = $output.AppendLine()
                    $null = $output.AppendLine($exampleContent)
                }
            }
            else
            {
                Write-Warning -Message ($script:localizedData.NoExampleFileFoundWarning -f $resourceSchema.FriendlyName)
            }

            $outputFileName = "$($resourceSchema.FriendlyName).md"
            $savePath = Join-Path -Path $OutputPath -ChildPath $outputFileName

            Write-Verbose -Message ($script:localizedData.OutputWikiPageMessage -f $savePath)

            $null = Out-File `
                -InputObject ($output.ToString() -replace '\r?\n', "`r`n") `
                -FilePath $savePath `
                -Encoding utf8 `
                -Force
        }
        elseif ($readmeFile.Count -gt 1)
        {
            Write-Warning -Message ($script:localizedData.MultipleDescriptionFileFoundWarning -f $resourceSchema.FriendlyName, $readmeFile.Count)
        }
        else
        {
            Write-Warning -Message ($script:localizedData.NoDescriptionFileFoundWarning -f $resourceSchema.FriendlyName)
        }
    }
}
#EndRegion './Public/New-DscResourceWikiPage.ps1' 162
#Region './Public/Publish-WikiContent.ps1' 0
<#
    .SYNOPSIS
        Publishes the Wiki Content that is generated by New-DscResourceWikiPage.

    .DESCRIPTION
        This function publishes the content pages from the Wiki Content that is
        generated by New-DscResourceWikiPage along with any additional files
        stored in the 'WikiSource' directory of the repository and an auto-generated
        sidebar file containing links to all the markdown files to the Wiki of a
        specified GitHub repository.

    .PARAMETER Path
        The path to the output that was generated by New-DscResourceWikiPage.

    .PARAMETER OwnerName
        The owner name of the Github repository.

    .PARAMETER RepositoryName
        The name of the Github repository.

    .PARAMETER ModuleName
        The name of the Dsc Resource Module.

    .PARAMETER ModuleVersion
        The build version number to tag the Wiki Github commit with.

    .PARAMETER GitHubAccessToken
        The GitHub access token to allow a push to the GitHub Wiki.

    .PARAMETER GitUserEmail
        The email address to use for the Git commit.

    .PARAMETER GitUserName
        The user name to use for the Git commit.

    .EXAMPLE
        Publish-WikiContent `
            -Path '.\output\WikiContent' `
            -OwnerName 'dsccommunity' `
            -RepositoryName 'SqlServerDsc' `
            -ModuleName 'SqlServerDsc' `
            -ModuleVersion '14.0.0' `
            -GitHubAccessToken 'token' `
            -GitUserEmail 'email@contoso.com' `
            -GitUserName 'dsc' `
            -WikiSourcePath '.\source\WikiSource'

        Adds the content pages in '.\output\WikiContent' to the Wiki for the
        specified GitHub repository.
#>
function Publish-WikiContent
{
    [CmdletBinding()]
    param
    (
        [Parameter(Mandatory = $true)]
        [System.String]
        $Path,

        [Parameter(Mandatory = $true)]
        [System.String]
        $OwnerName,

        [Parameter(Mandatory = $true)]
        [System.String]
        $RepositoryName,

        [Parameter(Mandatory = $true)]
        [System.String]
        $ModuleName,

        [Parameter(Mandatory = $true)]
        [System.String]
        $ModuleVersion,

        [Parameter(Mandatory = $true)]
        [System.String]
        $GitHubAccessToken,

        [Parameter(Mandatory = $true)]
        [System.String]
        $GitUserEmail,

        [Parameter(Mandatory = $true)]
        [System.String]
        $GitUserName,

        [Parameter()]
        [ValidateSet('true','false','input')]
        [System.String]
        $GlobalCoreAutoCrLf
    )

    $ErrorActionPreference = 'Stop'

    $headers = @{
        'Content-type' = 'application/json'
    }

    Write-Verbose -Message $script:localizedData.CreateTempDirMessage

    $tempPath = New-TempFolder

    try
    {
        Push-Location

        Write-Verbose -Message $script:localizedData.ConfigGlobalGitMessage

        if ($PSBoundParameters.ContainsKey('GlobalCoreAutoCrLf'))
        {
            $null = Invoke-Git -Arguments 'config', '--global', 'core.autocrlf', $GlobalCoreAutoCrLf
        }

        $wikiRepoName = "https://github.com/$OwnerName/$RepositoryName.wiki.git"

        Write-Verbose -Message ($script:localizedData.CloneWikiGitRepoMessage -f $WikiRepoName)

        $null = Invoke-Git -Arguments 'clone', $wikiRepoName, $tempPath, '--quiet'

        $copyWikiFileParameters = @{
            Path = $Path
            DestinationPath = $tempPath
            Force = $true
        }

        Copy-WikiFolder @copyWikiFileParameters

        New-WikiSidebar -ModuleName $ModuleName -Path $tempPath
        New-WikiFooter -Path $tempPath

        Set-Location -Path $tempPath

        Write-Verbose -Message $script:localizedData.ConfigLocalGitMessage

        $null = Invoke-Git -Arguments 'config', '--local', 'user.email', $GitUserEmail
        $null = Invoke-Git -Arguments 'config', '--local', 'user.name', $GitUserName
        $null = Invoke-Git -Arguments 'remote', 'set-url', 'origin', "https://$($GitUserName):$($GitHubAccessToken)@github.com/$OwnerName/$RepositoryName.wiki.git"

        Write-Verbose -Message $localizedData.AddWikiContentToGitRepoMessage

        $null = Invoke-Git -Arguments 'add', '*'

        Write-Verbose -Message ($localizedData.CommitAndTagRepoChangesMessage -f $ModuleVersion)

        $invokeGitResult = Invoke-Git -Arguments 'commit', '--message', ($localizedData.UpdateWikiCommitMessage -f $ModuleVersion), '--quiet'
        if ($invokeGitResult -eq 0)
        {
            $null = Invoke-Git -Arguments 'tag', '--annotate', $ModuleVersion, '--message', $ModuleVersion

            Write-Verbose -Message $localizedData.PushUpdatedRepoMessage

            $null = Invoke-Git -Arguments 'push', 'origin', '--quiet'
            $null = Invoke-Git -Arguments 'push', 'origin', $ModuleVersion, '--quiet'

            Write-Verbose -Message $localizedData.PublishWikiContentCompleteMessage
        }
        else
        {
            Write-Warning -Message $localizedData.NothingToCommitToWiki
        }
    }
    finally
    {
        Pop-Location

        Remove-Item -Path $tempPath -Recurse -Force
    }
}
#EndRegion './Public/Publish-WikiContent.ps1' 169
#Region './Public/Set-WikiModuleVersion.ps1' 0
<#
    .SYNOPSIS
        Sets the module version in a markdown file.

    .DESCRIPTION
        Sets the module version in a markdown file. Parses the markdown file for
        #.#.# which is replaced by the specified module version.

    .PARAMETER Path
        The path to a markdown file to set the module version in.

    .PARAMETER ModuleVersion
        The base name of the Wiki Sidebar file. Defaults to '_Sidebar.md'.

    .EXAMPLE
        Set-WikiModuleVersion -Path '.\output\WikiContent\Home.md' -ModuleVersion '14.0.0'

        Replaces '#.#.#' with the module version '14.0.0' in the markdown file 'Home.md'.
#>
function Set-WikiModuleVersion
{
    [CmdletBinding()]
    param
    (
        [Parameter(Mandatory = $true)]
        [System.String]
        $Path,

        [Parameter(Mandatory = $true)]
        [System.String]
        $ModuleVersion
    )

    $markdownContent = Get-Content -Path $path -Raw

    $markdownContent = $markdownContent -replace '#\.#\.#', $ModuleVersion

    Out-File -InputObject $markdownContent -FilePath $Path -Encoding ([System.Text.Encoding]::ASCII) -NoNewline
}
#EndRegion './Public/Set-WikiModuleVersion.ps1' 39
